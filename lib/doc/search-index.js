var searchIndex={};
searchIndex["net_ensembles"] = {"doc":"I am writing this libary for my scientific simulations","i":[[0,"example_nodes","net_ensembles","Trait needed for ER graphs etc.",null,null],[3,"TestNode","net_ensembles::example_nodes","minimal example for a node",null,null],[3,"EmptyNode","","Use this, if you do not need to store extra information",null,null],[0,"graph","net_ensembles","Topology Implements a network.",null,null],[3,"NodeContainer","net_ensembles::graph","Used for accessing neighbor information from graph *…",null,null],[3,"GenericGraph","","",null,null],[3,"Bfs","","Breadth first search Iterator with index and depth of…",null,null],[3,"DfsWithIndex","","Depth first search Iterator with index of corresponding…",null,null],[3,"Dfs","","Depth first search Iterator",null,null],[6,"Graph","","Contains the topology and implements functions for…",null,null],[17,"DEFAULT_DOT_OPTIONS","","constant for dot options `pub const DEFAULT_DOT_OPTIONS:…",null,null],[11,"new","","Create new graph with `size` nodes and no edges",0,[[["u32"]],["self"]]],[11,"clear_edges","","removes all edges from the graph * inexpensive O(1), if…",0,[[["self"]]]],[11,"sort_adj","","Sort adjecency lists * If you depend on the order of the…",0,[[["self"]]]],[11,"parse_str","","parse from str * tries to parse `Graph` from a `str`. *…",0,[[["str"]],["option"]]],[11,"container","","get NodeContainer at index * use this to iterate over…",0,[[["self"],["usize"]],["a"]]],[11,"container_iter","","get iterator over NodeContainer in order of the indices",0,[[["self"]],["iter"]]],[11,"at","","For your calculations etc. * read access to your struct T,…",0,[[["self"],["usize"]],["t"]]],[11,"at_mut","","For your calculations etc. * write access to your struct…",0,[[["self"],["usize"]],["t"]]],[11,"vertex_count","","returns number of vertices present in graph",0,[[["self"]],["u32"]]],[11,"average_degree","","",0,[[["self"]],["f32"]]],[11,"add_edge","","Adds edge between nodes `index1` and `index2` ##…",0,[[["self"],["u32"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"remove_edge","","Removes edge between nodes index1 and index2 ##…",0,[[["self"],["u32"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"edge_count","","returns total number of edges in graph",0,[[["self"]],["u32"]]],[11,"edge_count_at","","",0,[[["self"],["usize"]],[["option",["usize"]],["usize"]]]],[11,"dfs","","returns `Iterator`",0,[[["u32"],["self"]],["dfs"]]],[11,"dfs_with_index","","returns `Iterator`",0,[[["u32"],["self"]],["dfswithindex"]]],[11,"bfs_index_depth","","returns `Iterator`",0,[[["u32"],["self"]],["bfs"]]],[11,"is_connected","","| result | condition |…",0,[[["self"]],[["bool"],["option",["bool"]]]]],[11,"q_core","","definition Calculates the size of the q-core (i.e. number…",0,[[["u32"],["self"]],[["option",["u32"]],["u32"]]]],[11,"connected_components","","compute sizes of all connected components",0,[[["self"]],[["u32"],["vec",["u32"]]]]],[11,"leaf_count","","Count number of leaves in the graph, i.e. vertices with…",0,[[["self"]],["usize"]]],[11,"to_dot","","",0,[[["self"]],["string"]]],[11,"to_dot_with_labels","","Example ``` use std::fs::File; use std::io::prelude::*;…",0,[[["str"],["self"],["f"]],["string"]]],[11,"diameter","","`None`",0,[[["self"]],[["option",["u32"]],["u32"]]]],[11,"longest_shortest_path_from_index","","calculate the size of the longest shortest path starting…",0,[[["u32"],["self"]],[["option",["u32"]],["u32"]]]],[11,"vertex_biconnected_components","","calculate sizes of all binode connected components *…",0,[[["bool"]],[["usize"],["vec",["usize"]]]]],[11,"vertex_load","","Closely related (most of the time equal) to betweeness ##…",0,[[["self"],["bool"]],[["vec",["f64"]],["f64"]]]],[11,"transitivity","","Calculates transitivity of graph * related to cluster…",0,[[["self"]],["f64"]]],[0,"er","net_ensembles","Create Erdős-Rényi networks",null,null],[3,"ER","net_ensembles::er","Implements Erdős-Rényi graph",null,null],[4,"ErStep","","Returned by Monte Carlo Steps",null,null],[13,"Nothing","","nothing was changed",1,null],[13,"AddedEdge","","an edge was added",1,null],[13,"RemovedEdge","","an edge was removed",1,null],[11,"new","","Initialize * create new ER graph with `n` vertices *…",2,[[["u32"],["f64"],["r"]],["self"]]],[11,"randomize","","Randomizes the edges according to Er probabilities * this…",2,[[["self"]]]],[11,"target_connectivity","","returns target connectivity # Explanation The target…",2,[[["self"]],["f64"]]],[11,"random_step","","Monte Carlo steps * use this to perform a Monte Carlo step…",2,[[["self"]],["erstep"]]],[11,"random_steps","","Monte Carlo steps * use this to perform multiple Monte…",2,[[["self"],["usize"]],[["vec",["erstep"]],["erstep"]]]],[11,"undo_step","","Undo a Monte Carlo step * adds removed edge, or removes…",2,[[["self"],["erstep"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"undo_steps","","Undo a Monte Carlo step * adds removed edges, removes…",2,[[["self"],["vec",["erstep"]],["erstep"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"sort_adj","","Sorting adjecency lists * calls `sort_unstable()` on all…",2,[[["self"]]]],[11,"graph","","returns reference to the underlying topology aka, the…",2,[[["self"]],["graph"]]],[11,"rng","","Access RNG If, for some reason, you want access to the…",2,[[["self"]],["r"]]],[0,"graph_traits","net_ensembles","",null,null],[4,"GraphErrors","net_ensembles::graph_traits","Error messages",null,null],[13,"EdgeExists","","somehow, the existing of the edge is a problem Did you try…",3,null],[13,"EdgeDoesNotExist","","ERROR 404: Edge not found ;) Did you try to delete a non…",3,null],[13,"IndexOutOfRange","","Have you tried a smaller index?",3,null],[13,"IdenticalIndices","","No self loops allowed! Meaning you can't:…",3,null],[8,"Node","","What every node should be able to do",null,null],[10,"new_from_index","","how to construct a blank object",4,[[["u32"]],["self"]]],[11,"make_string","","Override this, if you want to store the network",4,[[["self"]],[["string"],["option",["string"]]]]],[11,"parse_str","","Override this, if you want to load the stored network",4,[[["str"]],["option"]]],[8,"AdjContainer","","",null,null],[10,"new","","",5,[[["u32"],["t"]],["self"]]],[10,"parse_str","","parse from str * tries to parse a AdjContainer from a…",5,[[["str"]],["option"]]],[10,"contained","","return reference to what the AdjContainer contains",5,[[["self"]],["t"]]],[10,"contained_mut","","return mut reference to what the AdjContainer contains",5,[[["self"]],["t"]]],[10,"neighbors","","returns iterator over indices of neighbors",5,[[["self"]],[["iter",["u32"]],["u32"]]]],[10,"neighbor_count","","count number of neighbors, i.e. number of edges incident…",5,[[["self"]],["usize"]]],[10,"id","","returns id of container",5,[[["self"]],["u32"]]],[10,"get_adj_first","","returns `Some(first element from the adjecency List)` or…",5,[[["self"]],[["option",["u32"]],["u32"]]]],[10,"is_adjacent","","check if vertex with `other_id` is adjacent to self ##…",5,[[["u32"],["self"]],["bool"]]],[10,"sort_adj","","Sorting adjecency lists",5,[[["self"]]]],[10,"clear_edges","","Remove all edges # Important * will not clear edges of…",5,[[["self"]]]],[10,"push","","What does it do? Creates edge in `self` and `other`s…",5,[[["self"]],[["result",["grapherrors"]],["grapherrors"]]]],[10,"remove","","What does it do? Removes edge in `self` and `other`s…",5,[[["self"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"to_str","","get error message as `&str`, for printing etc.",3,[[["self"]],["str"]]],[0,"traits","net_ensembles","",null,null],[11,"from","net_ensembles::example_nodes","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,[[["self"],["t"]]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"to_owned","","",7,[[["self"]],["t"]]],[11,"clone_into","","",7,[[["self"],["t"]]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","net_ensembles::graph","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"to_owned","","",8,[[["self"]],["t"]]],[11,"clone_into","","",8,[[["self"],["t"]]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"vzip","","",8,[[],["v"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"into_iter","","",9,[[],["i"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"into_iter","","",10,[[],["i"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"vzip","","",10,[[],["v"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"into_iter","","",11,[[],["i"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"vzip","","",11,[[],["v"]]],[11,"from","net_ensembles::er","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","net_ensembles::graph_traits","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"vzip","","",3,[[],["v"]]],[11,"new_from_index","net_ensembles::example_nodes","",6,[[["u32"]],["self"]]],[11,"new_from_index","","",7,[[["u32"]],["self"]]],[11,"make_string","","",7,[[["self"]],[["string"],["option",["string"]]]]],[11,"parse_str","","",7,[[["str"]],["option"]]],[11,"new","net_ensembles::graph","",8,[[["u32"],["t"]],["self"]]],[11,"parse_str","","parse from str * tries to parse a NodeContainer from a…",8,[[["str"]],["option"]]],[11,"contained","","return reference to what the NodeContainer contains",8,[[["self"]],["t"]]],[11,"contained_mut","","return mut reference to what the NodeContainer contains",8,[[["self"]],["t"]]],[11,"neighbors","","returns iterator over indices of neighbors",8,[[["self"]],[["iter",["u32"]],["u32"]]]],[11,"neighbor_count","","count number of neighbors, i.e. number of edges incident…",8,[[["self"]],["usize"]]],[11,"id","","returns id of container ## Note: (in `Graph<T>`: `id`…",8,[[["self"]],["u32"]]],[11,"is_adjacent","","check if vertex with `other_id` is adjacent to self ##…",8,[[["u32"],["self"]],["bool"]]],[11,"sort_adj","","Sorting adjecency lists * calls `sort_unstable()` on all…",8,[[["self"]]]],[11,"clear_edges","","",8,[[["self"]]]],[11,"push","","",8,[[["self"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"remove","","Tries to remove edges, returns error…",8,[[["self"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"get_adj_first","","",8,[[["self"]],[["option",["u32"]],["u32"]]]],[11,"next","","",9,[[["self"]],["option"]]],[11,"next","","",10,[[["self"]],["option"]]],[11,"next","","",11,[[["self"]],["option"]]],[11,"clone","net_ensembles::example_nodes","",6,[[["self"]],["testnode"]]],[11,"clone","","",7,[[["self"]],["emptynode"]]],[11,"clone","net_ensembles::graph","",8,[[["self"]],["nodecontainer"]]],[11,"clone","","",0,[[["self"]],["genericgraph"]]],[11,"clone","net_ensembles::er","",1,[[["self"]],["erstep"]]],[11,"clone","","",2,[[["self"]],["er"]]],[11,"fmt","net_ensembles::example_nodes","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::graph","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::er","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::graph_traits","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::graph","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::graph_traits","",3,[[["formatter"],["self"]],["result"]]]],"p":[[3,"GenericGraph"],[4,"ErStep"],[3,"ER"],[4,"GraphErrors"],[8,"Node"],[8,"AdjContainer"],[3,"TestNode"],[3,"EmptyNode"],[3,"NodeContainer"],[3,"Bfs"],[3,"DfsWithIndex"],[3,"Dfs"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);