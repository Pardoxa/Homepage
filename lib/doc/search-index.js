var searchIndex={};
searchIndex["net_ensembles"] = {"doc":"Libary for my simulations Here I will define the node…","i":[[0,"node","net_ensembles","Trait needed for ER graphs etc.",null,null],[3,"TestNode","net_ensembles::node","minimal example for a node",null,null],[8,"Node","","What every node should be able to do",null,null],[10,"new_from_index","","how to construct a blank object",0,[[["u32"]],["self"]]],[11,"make_string","","Override this, if you want to store the network",0,[[["self"]],[["string"],["option",["string"]]]]],[11,"parse_str","","Override this, if you want to load the stored network",0,[[["str"]],["option"]]],[0,"graph","net_ensembles","Topology Implements a network.",null,null],[3,"NodeContainer","net_ensembles::graph","Used for accessing neighbor information from graph…",null,null],[3,"Graph","","Contains the topology and implements functions for…",null,null],[3,"Bfs","","Breadth first search Iterator with index and depth of…",null,null],[3,"DfsWithIndex","","Depth first search Iterator with index of corresponding…",null,null],[3,"Dfs","","Depth first search Iterator",null,null],[4,"GraphErrors","","Error messages",null,null],[13,"EdgeExists","","somehow, the existing of the edge is a problem Did you try…",1,null],[13,"EdgeDoesNotExist","","ERROR 404: Edge not found ;) Did you try to delete a non…",1,null],[13,"IndexOutOfRange","","Have you tried a smaller index?",1,null],[13,"IdenticalIndices","","No self loops allowed! Meaning you can't:…",1,null],[17,"DEFAULT_DOT_OPTIONS","","constant for dot options `pub const DEFAULT_DOT_OPTIONS:…",null,null],[11,"to_str","","get error message as `&str`, for printing etc.",1,[[["self"]],["str"]]],[11,"parse_str","","parse from str * tries to parse a NodeContainer from a…",2,[[["str"]],["option"]]],[11,"contained","","return reference to what the NodeContainer contains",2,[[["self"]],["t"]]],[11,"contained_mut","","return mut reference to what the NodeContainer contains",2,[[["self"]],["t"]]],[11,"neighbors","","returns iterator over indices of neighbors",2,[[["self"]],[["iter",["u32"]],["u32"]]]],[11,"neighbor_count","","count number of neighbors, i.e. number of edges incident…",2,[[["self"]],["usize"]]],[11,"id","","returns id of container ## Note: (in `Graph<T>`: `id`…",2,[[["self"]],["u32"]]],[11,"is_adjacent","","check if vertex with `other_id` is adjacent to self ##…",2,[[["u32"],["self"]],["bool"]]],[11,"new","","Create new graph with `size` nodes and no edges",3,[[["u32"]],["self"]]],[11,"clear_edges","","removes all edges from the graph * inexpensive O(1), if…",3,[[["self"]]]],[11,"sort_adj","","Sort adjecency lists * If you depend on the order of the…",3,[[["self"]]]],[11,"parse_str","","parse from str * tries to parse `Graph` from a `str`. *…",3,[[["str"]],["option"]]],[11,"container","","get NodeContainer at index * use this to iterate over…",3,[[["self"],["usize"]],["nodecontainer"]]],[11,"container_iter","","get iterator over NodeContainer in order of the indices",3,[[["self"]],[["iter",["nodecontainer"]],["nodecontainer"]]]],[11,"at","","For your calculations etc. * read access to your struct T,…",3,[[["self"],["usize"]],["t"]]],[11,"at_mut","","For your calculations etc. * write access to your struct…",3,[[["self"],["usize"]],["t"]]],[11,"vertex_count","","returns number of vertices present in graph",3,[[["self"]],["u32"]]],[11,"average_neighbor_count","","",3,[[["self"]],["f32"]]],[11,"add_edge","","Adds edge between nodes `index1` and `index2` ##…",3,[[["self"],["u32"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"remove_edge","","Removes edge between nodes index1 and index2 ##…",3,[[["self"],["u32"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"edge_count","","returns total number of edges in graph",3,[[["self"]],["u32"]]],[11,"edge_count_at","","",3,[[["self"],["usize"]],[["option",["usize"]],["usize"]]]],[11,"dfs","","returns `Iterator`",3,[[["u32"],["self"]],["dfs"]]],[11,"dfs_with_index","","returns `Iterator`",3,[[["u32"],["self"]],["dfswithindex"]]],[11,"bfs_index_depth","","returns `Iterator`",3,[[["u32"],["self"]],["bfs"]]],[11,"is_connected","","| result | condition |…",3,[[["self"]],[["bool"],["option",["bool"]]]]],[11,"q_core","","definition Calculates the size of the q-core (i.e. number…",3,[[["u32"],["self"]],[["option",["u32"]],["u32"]]]],[11,"connected_components","","compute sizes of all connected components",3,[[["self"]],[["u32"],["vec",["u32"]]]]],[11,"leaf_count","","Count number of leaves in the graph, i.e. vertices with…",3,[[["self"]],["usize"]]],[11,"to_dot","","",3,[[["self"]],["string"]]],[11,"to_dot_with_labels","","Example ``` use std::fs::File; use std::io::prelude::*;…",3,[[["str"],["self"],["f"]],["string"]]],[11,"diameter","","`None`",3,[[["self"]],[["option",["u32"]],["u32"]]]],[11,"longest_shortest_path_from_index","","calculate the size of the longest shortest path starting…",3,[[["u32"],["self"]],[["option",["u32"]],["u32"]]]],[11,"vertex_biconnected_components","","calculate sizes of all binode connected components *…",3,[[["bool"]],[["usize"],["vec",["usize"]]]]],[11,"vertex_load","","Closely related (most of the time equal) to betweeness ##…",3,[[["self"],["bool"]],[["vec",["f64"]],["f64"]]]],[11,"transitivity","","Calculates transitivity of graph * related to cluster…",3,[[["self"]],["f64"]]],[0,"er","net_ensembles","Create Erdős-Rényi networks",null,null],[3,"ER","net_ensembles::er","Implements Erdős-Rényi graph",null,null],[4,"ErStep","","Returned by Monte Carlo Steps",null,null],[13,"Nothing","","nothing was changed",4,null],[13,"AddedEdge","","an edge was added",4,null],[13,"RemovedEdge","","an edge was removed",4,null],[11,"new","","Initialize * create new ER graph with `n` vertices *…",5,[[["u32"],["f64"],["r"]],["self"]]],[11,"randomize","","Randomizes the edges according to Er probabilities * this…",5,[[["self"]]]],[11,"target_connectivity","","returns target connectivity # Explanation The target…",5,[[["self"]],["f64"]]],[11,"random_step","","Monte Carlo steps * use this to perform a Monte Carlo step…",5,[[["self"]],["erstep"]]],[11,"random_steps","","Monte Carlo steps * use this to perform multiple Monte…",5,[[["self"],["usize"]],[["vec",["erstep"]],["erstep"]]]],[11,"undo_step","","Undo a Monte Carlo step * adds removed edge, or removes…",5,[[["self"],["erstep"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"undo_steps","","Undo a Monte Carlo step * adds removed edges, removes…",5,[[["self"],["vec",["erstep"]],["erstep"]],[["result",["grapherrors"]],["grapherrors"]]]],[11,"sort_adj","","Sorting adjecency lists * calls `sort_unstable()` on all…",5,[[["self"]]]],[11,"graph","","returns reference to the underlying topology aka, the…",5,[[["self"]],["graph"]]],[11,"rng","","Access RNG If, for some reason, you want access to the…",5,[[["self"]],["r"]]],[11,"from","net_ensembles::node","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,[[["self"],["t"]]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","net_ensembles::graph","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"into_iter","","",7,[[],["i"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"into_iter","","",8,[[],["i"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"vzip","","",8,[[],["v"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"into_iter","","",9,[[],["i"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","net_ensembles::er","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"to_owned","","",5,[[["self"]],["t"]]],[11,"clone_into","","",5,[[["self"],["t"]]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"vzip","","",4,[[],["v"]]],[11,"new_from_index","net_ensembles::node","",6,[[["u32"]],["self"]]],[11,"next","net_ensembles::graph","",7,[[["self"]],["option"]]],[11,"next","","",8,[[["self"]],["option"]]],[11,"next","","",9,[[["self"]],["option"]]],[11,"clone","net_ensembles::node","",6,[[["self"]],["testnode"]]],[11,"clone","net_ensembles::graph","",2,[[["self"]],["nodecontainer"]]],[11,"clone","","",3,[[["self"]],["graph"]]],[11,"clone","net_ensembles::er","",4,[[["self"]],["erstep"]]],[11,"clone","","",5,[[["self"]],["er"]]],[11,"fmt","net_ensembles::graph","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::er","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",5,[[["formatter"],["self"]],["result"]]],[11,"fmt","net_ensembles::graph","",1,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",2,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]]],"p":[[8,"Node"],[4,"GraphErrors"],[3,"NodeContainer"],[3,"Graph"],[4,"ErStep"],[3,"ER"],[3,"TestNode"],[3,"Bfs"],[3,"DfsWithIndex"],[3,"Dfs"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);