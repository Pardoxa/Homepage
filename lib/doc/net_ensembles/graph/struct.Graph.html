<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Graph` struct in crate `net_ensembles`."><meta name="keywords" content="rust, rustlang, rust-lang, Graph"><title>net_ensembles::graph::Graph - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css"><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="shortcut icon" href="../../favicon.ico"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../net_ensembles/index.html'><div class='logo-container'><img src='../../rust-logo.png' alt='logo'></div></a><p class='location'>Struct Graph</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#methods">Methods</a><div class="sidebar-links"><a href="#method.add_edge">add_edge</a><a href="#method.at">at</a><a href="#method.at_mut">at_mut</a><a href="#method.average_degree">average_degree</a><a href="#method.bfs_index_depth">bfs_index_depth</a><a href="#method.clear_edges">clear_edges</a><a href="#method.connected_components">connected_components</a><a href="#method.container">container</a><a href="#method.container_iter">container_iter</a><a href="#method.dfs">dfs</a><a href="#method.dfs_with_index">dfs_with_index</a><a href="#method.diameter">diameter</a><a href="#method.edge_count">edge_count</a><a href="#method.edge_count_at">edge_count_at</a><a href="#method.is_connected">is_connected</a><a href="#method.leaf_count">leaf_count</a><a href="#method.longest_shortest_path_from_index">longest_shortest_path_from_index</a><a href="#method.new">new</a><a href="#method.parse_str">parse_str</a><a href="#method.q_core">q_core</a><a href="#method.remove_edge">remove_edge</a><a href="#method.sort_adj">sort_adj</a><a href="#method.to_dot">to_dot</a><a href="#method.to_dot_with_labels">to_dot_with_labels</a><a href="#method.transitivity">transitivity</a><a href="#method.vertex_biconnected_components">vertex_biconnected_components</a><a href="#method.vertex_count">vertex_count</a><a href="#method.vertex_load">vertex_load</a></div><a class="sidebar-title" href="#implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Debug">Debug</a><a href="#impl-Display">Display</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">RefUnwindSafe</a><a href="#impl-Send">Send</a><a href="#impl-Sync">Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-ToString">ToString</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a><a href="#impl-VZip%3CV%3E">VZip&lt;V&gt;</a></div></div><p class='location'><a href='../index.html'>net_ensembles</a>::<wbr><a href='index.html'>graph</a></p><script>window.sidebarCurrent = {name: 'Graph', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../../src/net_ensembles/graph.rs.html#481-485' title='goto source code'>[src]</a></span><span class='in-band'>Struct <a href='../index.html'>net_ensembles</a>::<wbr><a href='index.html'>graph</a>::<wbr><a class="struct" href=''>Graph</a></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class='rust struct'>pub struct Graph&lt;T:&nbsp;<a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>&gt; { /* fields omitted */ }</pre></div><div class='docblock'><h1 id="contains-the-topology-and-implements-functions-for-analyzing-topology" class="section-header"><a href="#contains-the-topology-and-implements-functions-for-analyzing-topology">Contains the topology and <strong>implements functions</strong> for analyzing topology</a></h1>
<p>used for graph ensembles</p>
<h1 id="example" class="section-header"><a href="#example">Example:</a></h1>
<p>A graph, where each node stores a phase</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">net_ensembles</span>::{<span class="ident">Node</span>,<span class="ident">Graph</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="comment">// define your own vertices, if you need to store extra information at each vertex</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">PhaseNode</span> {<span class="ident">phase</span>: <span class="ident">f64</span>,}

<span class="comment">// implement whatever you need</span>
<span class="kw">impl</span> <span class="ident">PhaseNode</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_phase</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">phase</span>: <span class="ident">f64</span>) {
        <span class="self">self</span>.<span class="ident">phase</span> <span class="op">=</span> <span class="ident">phase</span>;
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_phase</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span> {
        <span class="self">self</span>.<span class="ident">phase</span>
    }
}

<span class="comment">// implement the trait `Node`</span>
<span class="kw">impl</span> <span class="ident">Node</span> <span class="kw">for</span> <span class="ident">PhaseNode</span> {
    <span class="kw">fn</span> <span class="ident">new_from_index</span>(<span class="ident">index</span>: <span class="ident">u32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
        <span class="ident">PhaseNode</span> { <span class="ident">phase</span>: <span class="ident">index</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">10.0</span>}
    }
}

<span class="comment">// now you can create an empty graph</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">graph</span>: <span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">PhaseNode</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Graph</span>::<span class="ident">new</span>(<span class="number">4</span>);
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
      <span class="ident">graph</span>.<span class="ident">at</span>(<span class="ident">i</span>).<span class="ident">get_phase</span>(),
      <span class="ident">i</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">10.0</span>
    );
}

<span class="comment">// and fill it with edges</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="ident">graph</span>.<span class="ident">add_edge</span>(<span class="ident">i</span>, (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="op">%</span> <span class="number">4</span>).<span class="ident">unwrap</span>();
}


<span class="comment">// you can manipulate the extra information stored at each Vertex</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="ident">graph</span>.<span class="ident">at_mut</span>(<span class="ident">i</span>).<span class="ident">set_phase</span>(<span class="ident">i</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">0.5</span>);
}

<span class="comment">// you can, of course, also access the information</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="ident">graph</span>.<span class="ident">at</span>(<span class="ident">i</span>).<span class="ident">get_phase</span>(),
        <span class="ident">i</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">0.5</span>
    );
}

<span class="comment">// if you want to visualize your graph, you can generate a string with graphviz representation</span>
<span class="kw">let</span> <span class="ident">dot</span> <span class="op">=</span> <span class="ident">graph</span>.<span class="ident">to_dot_with_labels</span>(
    <span class="string">&quot;&quot;</span>,
    <span class="op">|</span><span class="ident">contained</span>, <span class="ident">index</span><span class="op">|</span>
           <span class="macro">format</span><span class="macro">!</span>(
                <span class="string">&quot;Phase: {} at index {}&quot;</span>,
                <span class="ident">contained</span>.<span class="ident">get_phase</span>(),
                <span class="ident">index</span>
            )
);
<span class="comment">// which you can store in a dot file</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;phase_example.dot&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;Unable to create file&quot;</span>);
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">dot</span>.<span class="ident">as_bytes</span>()).<span class="ident">expect</span>(<span class="string">&quot;Unable to write data&quot;</span>);

<span class="comment">// or just print it out</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">dot</span>);</pre></div>
<p><code>phase_example.dot</code> will then contain</p>
<pre><code class="language-dot">graph G{

	0 1 2 3 ;
	&quot;0&quot; [label=&quot;Phase: 0 at index 0&quot;];
	&quot;1&quot; [label=&quot;Phase: 0.5 at index 1&quot;];
	&quot;2&quot; [label=&quot;Phase: 1 at index 2&quot;];
	&quot;3&quot; [label=&quot;Phase: 1.5 at index 3&quot;];
	0 -- 1
	0 -- 3
	1 -- 2
	2 -- 3
}
</code></pre>
<p>Now you can use <code>circo</code> or similar programs to create a pdf from that.
Search for <strong>graphviz</strong> for more info.</p>
<h1 id="example-2" class="section-header"><a href="#example-2">Example 2</a></h1>
<ul>
<li>if you also want to be able to store your graph, you have to override two functions of the Node trait, as shown below</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">net_ensembles</span>::{<span class="ident">Node</span>,<span class="ident">Graph</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="comment">// define your own vertices, if you need to store extra information at each vertex</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">PhaseNode</span> {<span class="ident">phase</span>: <span class="ident">f64</span>,}

<span class="kw">impl</span> <span class="ident">PhaseNode</span> {
    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_phase</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">phase</span>: <span class="ident">f64</span>) {
        <span class="self">self</span>.<span class="ident">phase</span> <span class="op">=</span> <span class="ident">phase</span>;
    }

    <span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">get_phase</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">f64</span> {
        <span class="self">self</span>.<span class="ident">phase</span>
    }
}

<span class="kw">impl</span> <span class="ident">Node</span> <span class="kw">for</span> <span class="ident">PhaseNode</span> {
    <span class="kw">fn</span> <span class="ident">new_from_index</span>(<span class="ident">index</span>: <span class="ident">u32</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
        <span class="ident">PhaseNode</span> { <span class="ident">phase</span>: <span class="number">10.0</span> <span class="op">*</span> <span class="ident">index</span> <span class="kw">as</span> <span class="ident">f64</span> }
    }

    <span class="comment">// Override this, to save the graph</span>
    <span class="kw">fn</span> <span class="ident">make_string</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> {
        <span class="prelude-val">Some</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;phase: {},&quot;</span>, <span class="self">self</span>.<span class="ident">phase</span>))
    }

    <span class="comment">// Override this, since you want to load the stored graph</span>
    <span class="kw">fn</span> <span class="ident">parse_str</span>(<span class="ident">to_parse</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="self">Self</span>)<span class="op">&gt;</span>
        <span class="kw">where</span> <span class="self">Self</span>: <span class="ident">Sized</span>
    {
        <span class="kw">let</span> <span class="ident">identifier</span> <span class="op">=</span> <span class="string">&quot;phase: &quot;</span>;
        <span class="comment">// searching for identifier</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">split_index</span> <span class="op">=</span> <span class="ident">to_parse</span>.<span class="ident">find</span>(<span class="ident">identifier</span>)<span class="question-mark">?</span>;

        <span class="comment">// add length of identifier to index</span>
        <span class="ident">split_index</span> <span class="op">+</span><span class="op">=</span> <span class="ident">identifier</span>.<span class="ident">len</span>();

        <span class="comment">// new string slice to skip to our identifier</span>
        <span class="kw">let</span> <span class="ident">remaining_to_parse</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">to_parse</span>[<span class="ident">split_index</span>..];

        <span class="comment">// find out, where our data ends</span>
        <span class="ident">split_index</span> <span class="op">=</span> <span class="ident">remaining_to_parse</span>.<span class="ident">find</span>(<span class="string">&quot;,&quot;</span>)<span class="question-mark">?</span>;

        <span class="comment">// create new string slice, beginning after what Node::make_string() created</span>
        <span class="kw">let</span> (<span class="ident">phase_str</span>, <span class="kw-2">mut</span> <span class="ident">remaining_to_parse</span>) <span class="op">=</span> <span class="ident">remaining_to_parse</span>.<span class="ident">split_at</span>(<span class="ident">split_index</span>);
        <span class="ident">remaining_to_parse</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">remaining_to_parse</span>[<span class="number">1</span>..];

        <span class="comment">// parse our data</span>
        <span class="kw">let</span> <span class="ident">phase</span> <span class="op">=</span> <span class="ident">phase_str</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">f64</span><span class="op">&gt;</span>().<span class="ident">ok</span>()<span class="question-mark">?</span>;
        <span class="kw">let</span> <span class="ident">node</span> <span class="op">=</span> <span class="ident">PhaseNode</span>{ <span class="ident">phase</span> };

        <span class="comment">// return our struct as option</span>
        <span class="prelude-val">Some</span>((<span class="ident">remaining_to_parse</span>, <span class="ident">node</span>))
    }
}

<span class="comment">// now you can create an empty graph</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">graph</span>: <span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">PhaseNode</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Graph</span>::<span class="ident">new</span>(<span class="number">4</span>);
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
      <span class="ident">graph</span>.<span class="ident">at</span>(<span class="ident">i</span>).<span class="ident">get_phase</span>(),
      <span class="ident">i</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">10.0</span>
    );
}

<span class="comment">// and fill it with edges</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="ident">graph</span>.<span class="ident">add_edge</span>(<span class="ident">i</span>, (<span class="ident">i</span> <span class="op">+</span> <span class="number">1</span>) <span class="op">%</span> <span class="number">4</span>).<span class="ident">unwrap</span>();
}


<span class="comment">// you can manipulate the extra information stored at each Vertex</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="ident">graph</span>.<span class="ident">at_mut</span>(<span class="ident">i</span>).<span class="ident">set_phase</span>(<span class="ident">i</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">0.5</span>);
}

<span class="comment">// you can, of course, also access the information</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(
        <span class="ident">graph</span>.<span class="ident">at</span>(<span class="ident">i</span>).<span class="ident">get_phase</span>(),
        <span class="ident">i</span> <span class="kw">as</span> <span class="ident">f64</span> <span class="op">*</span> <span class="number">0.5</span>
    );
}

<span class="comment">// if you want to visualize your graph, you can generate a string with graphviz representation</span>
<span class="kw">let</span> <span class="ident">dot</span> <span class="op">=</span> <span class="ident">graph</span>.<span class="ident">to_dot_with_labels</span>(
    <span class="string">&quot;&quot;</span>,
    <span class="op">|</span><span class="ident">contained</span>, <span class="ident">index</span><span class="op">|</span>
           <span class="macro">format</span><span class="macro">!</span>(
                <span class="string">&quot;Phase: {} at index {}&quot;</span>,
                <span class="ident">contained</span>.<span class="ident">get_phase</span>(),
                <span class="ident">index</span>
            )
);
<span class="comment">// which you can store in a dot file</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;phase_example_still_works.dot&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;Unable to create file&quot;</span>);
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">dot</span>.<span class="ident">as_bytes</span>()).<span class="ident">expect</span>(<span class="string">&quot;Unable to write data&quot;</span>);

<span class="comment">// or just print it out</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">dot</span>);

<span class="comment">// if you want to store your graph, you can do the following:</span>
<span class="comment">// first get string representation</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">graph</span>.<span class="ident">to_string</span>();
<span class="comment">// open file</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">graph_file</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;store_graph_example.dat&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;Unable to create file&quot;</span>);
<span class="comment">// write to file</span>
<span class="ident">graph_file</span>.<span class="ident">write_all</span>(<span class="ident">s</span>.<span class="ident">as_bytes</span>()).<span class="ident">expect</span>(<span class="string">&quot;Unable to write data&quot;</span>);
<span class="comment">// close file</span>
<span class="ident">drop</span>(<span class="ident">graph_file</span>);

<span class="comment">// now, if you want to load your network:</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">read_in</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">open</span>(<span class="string">&quot;store_graph_example.dat&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;unable to open file&quot;</span>);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">test_data</span> <span class="op">=</span> <span class="ident">String</span>::<span class="ident">new</span>();
<span class="ident">read_in</span>.<span class="ident">read_to_string</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">test_data</span>).<span class="ident">expect</span>(<span class="string">&quot;unable to read file&quot;</span>);

<span class="comment">// now we read the string. We still have to parse it:</span>
<span class="kw">let</span> (<span class="kw">_</span>, <span class="ident">graph2</span>) <span class="op">=</span> <span class="ident">Graph</span>::<span class="op">&lt;</span><span class="ident">PhaseNode</span><span class="op">&gt;</span>::<span class="ident">parse_str</span>(<span class="kw-2">&amp;</span><span class="ident">test_data</span>).<span class="ident">unwrap</span>();

<span class="comment">// now, to show, that the graphs are equal, here is one of my test functions:</span>
<span class="comment">// modified for this example, which is a doc-test, so this example also serves as unit test</span>

<span class="kw">fn</span> <span class="ident">assert_equal_graphs</span>(<span class="ident">g1</span>: <span class="kw-2">&amp;</span><span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">PhaseNode</span><span class="op">&gt;</span>, <span class="ident">g2</span>: <span class="kw-2">&amp;</span><span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">PhaseNode</span><span class="op">&gt;</span>) {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">g1</span>.<span class="ident">edge_count</span>(), <span class="ident">g2</span>.<span class="ident">edge_count</span>());
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">g1</span>.<span class="ident">vertex_count</span>(), <span class="ident">g2</span>.<span class="ident">vertex_count</span>());
    <span class="kw">for</span> (<span class="ident">n0</span>, <span class="ident">n1</span>) <span class="kw">in</span> <span class="ident">g2</span>.<span class="ident">container_iter</span>().<span class="ident">zip</span>(<span class="ident">g1</span>.<span class="ident">container_iter</span>()) {
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">n1</span>.<span class="ident">id</span>(), <span class="ident">n0</span>.<span class="ident">id</span>());
        <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">n0</span>.<span class="ident">neighbor_count</span>(), <span class="ident">n1</span>.<span class="ident">neighbor_count</span>());

        <span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">j</span>) <span class="kw">in</span> <span class="ident">n1</span>.<span class="ident">neighbors</span>().<span class="ident">zip</span>(<span class="ident">n0</span>.<span class="ident">neighbors</span>()) {
            <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">i</span>, <span class="ident">j</span>);
        }
    }

    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">g2</span>.<span class="ident">vertex_count</span>() <span class="kw">as</span> <span class="ident">usize</span> {
        <span class="macro">assert_eq</span><span class="macro">!</span>(
            <span class="ident">g1</span>.<span class="ident">at</span>(<span class="ident">i</span>).<span class="ident">get_phase</span>(),
            <span class="ident">g2</span>.<span class="ident">at</span>(<span class="ident">i</span>).<span class="ident">get_phase</span>()
        );
    }
}
<span class="comment">// lets use it</span>
<span class="ident">assert_equal_graphs</span>(<span class="kw-2">&amp;</span><span class="ident">graph</span>, <span class="kw-2">&amp;</span><span class="ident">graph2</span>);

<span class="comment">// you can also clone the graph, if you need:</span>
<span class="kw">let</span> <span class="ident">clone</span> <span class="op">=</span> <span class="ident">graph</span>.<span class="ident">clone</span>();
<span class="ident">assert_equal_graphs</span>(<span class="kw-2">&amp;</span><span class="ident">graph</span>, <span class="kw-2">&amp;</span><span class="ident">clone</span>);
<span class="kw">let</span> <span class="ident">clone2</span> <span class="op">=</span> <span class="ident">graph2</span>.<span class="ident">clone</span>();
<span class="ident">assert_equal_graphs</span>(<span class="kw-2">&amp;</span><span class="ident">clone</span>, <span class="kw-2">&amp;</span><span class="ident">clone2</span>);</pre></div>
</div><h2 id='methods' class='small-section-header'>Methods<a href='#methods' class='anchor'></a></h2><h3 id='impl' class='impl'><code class='in-band'>impl&lt;T:&nbsp;<a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>&gt; <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt;</code><a href='#impl' class='anchor'></a><a class='srclink' href='../../src/net_ensembles/graph.rs.html#497-1315' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.new' class="method"><code id='new.v'>pub fn <a href='#method.new' class='fnname'>new</a>(size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; Self</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#500-511' title='goto source code'>[src]</a></h4><div class='docblock'><p>Create new graph with <code>size</code> nodes
and no edges</p>
</div><h4 id='method.clear_edges' class="method"><code id='clear_edges.v'>pub fn <a href='#method.clear_edges' class='fnname'>clear_edges</a>(&amp;mut self)</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#516-523' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="removes-all-edges-from-the-graph" class="section-header"><a href="#removes-all-edges-from-the-graph">removes all edges from the graph</a></h1>
<ul>
<li>inexpensive O(1), if there are no edges to begin with</li>
<li>O(vertices) otherwise</li>
</ul>
</div><h4 id='method.sort_adj' class="method"><code id='sort_adj.v'>pub fn <a href='#method.sort_adj' class='fnname'>sort_adj</a>(&amp;mut self)</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#528-532' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="sort-adjecency-lists" class="section-header"><a href="#sort-adjecency-lists">Sort adjecency lists</a></h1>
<ul>
<li>If you depend on the order of the adjecency lists, you can sort them</li>
<li>keep in mind, that this can be costly</li>
</ul>
</div><h4 id='method.parse_str' class="method"><code id='parse_str.v'>pub fn <a href='#method.parse_str' class='fnname'>parse_str</a>(to_parse: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, Self<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#542-578' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="parse-from-str" class="section-header"><a href="#parse-from-str">parse from str</a></h1>
<ul>
<li>tries to parse <code>Graph</code> from a <code>str</code>.</li>
<li>will ignore leading whitespaces and other chars, as long as they do not match <code>&quot;next_id: &quot;</code></li>
<li>returns <code>None</code> if failed</li>
</ul>
<h2 id="return" class="section-header"><a href="#return">Return</a></h2>
<ol>
<li>returns string slice beginning directly after the part, that was used to parse</li>
<li>the <code>Graph</code> resulting form the parsing</li>
</ol>
</div><h4 id='method.container' class="method"><code id='container.v'>pub fn <a href='#method.container' class='fnname'>container</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="struct" href="../../net_ensembles/graph/struct.NodeContainer.html" title="struct net_ensembles::graph::NodeContainer">NodeContainer</a>&lt;T&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#586-588' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="get-nodecontainer-at-index" class="section-header"><a href="#get-nodecontainer-at-index">get NodeContainer at index</a></h1>
<ul>
<li>use this to iterate over neighbors</li>
<li>use this to check, if vertices are adjacent</li>
</ul>
<h1 id="warning" class="section-header"><a href="#warning">Warning</a></h1>
<ul>
<li><strong>panics</strong> if index out of bounds</li>
</ul>
</div><h4 id='method.container_iter' class="method"><code id='container_iter.v'>pub fn <a href='#method.container_iter' class='fnname'>container_iter</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/slice/struct.Iter.html" title="struct core::slice::Iter">Iter</a>&lt;<a class="struct" href="../../net_ensembles/graph/struct.NodeContainer.html" title="struct net_ensembles::graph::NodeContainer">NodeContainer</a>&lt;T&gt;&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#591-593' title='goto source code'>[src]</a></h4><div class='docblock'><p>get iterator over NodeContainer in order of the indices</p>
</div><h4 id='method.at' class="method"><code id='at.v'>pub fn <a href='#method.at' class='fnname'>at</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#602-604' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="for-your-calculations-etc" class="section-header"><a href="#for-your-calculations-etc">For your calculations etc.</a></h1>
<ul>
<li><strong>read access</strong> to <strong>your struct</strong> T, stored at <strong>each vertex</strong>, that implements <code>Node</code> trait</li>
<li>see first <strong>code example</strong> (beginning of this page)</li>
</ul>
</div><h4 id='method.at_mut' class="method"><code id='at_mut.v'>pub fn <a href='#method.at_mut' class='fnname'>at_mut</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#609-611' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="for-your-calculations-etc-1" class="section-header"><a href="#for-your-calculations-etc-1">For your calculations etc.</a></h1>
<ul>
<li><strong>write access</strong> to <strong>your struct</strong> T, stored at <strong>each vertex</strong>, that implements <code>Node</code> trait</li>
<li>see first <strong>code example</strong> (beginning of this page)</li>
</ul>
</div><h4 id='method.vertex_count' class="method"><code id='vertex_count.v'>pub fn <a href='#method.vertex_count' class='fnname'>vertex_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#614-616' title='goto source code'>[src]</a></h4><div class='docblock'><p>returns number of vertices present in graph</p>
</div><h4 id='method.average_degree' class="method"><code id='average_degree.v'>pub fn <a href='#method.average_degree' class='fnname'>average_degree</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f32.html">f32</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#618-620' title='goto source code'>[src]</a></h4><h4 id='method.add_edge' class="method"><code id='add_edge.v'>pub fn <a href='#method.add_edge' class='fnname'>add_edge</a>(&amp;mut self, index1: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, index2: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../net_ensembles/graph/enum.GraphErrors.html" title="enum net_ensembles::graph::GraphErrors">GraphErrors</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#654-659' title='goto source code'>[src]</a></h4><div class='docblock'><p>Adds edge between nodes <code>index1</code> and <code>index2</code></p>
<h2 id="errorcases" class="section-header"><a href="#errorcases">ErrorCases:</a></h2><table><thead><tr><th>Error</th><th>Reason</th></tr></thead><tbody>
<tr><td><code>GraphErrors::IndexOutOfRange</code></td><td><code>index1</code> or <code>index2</code> larger than <code>self.vertex_count()</code></td></tr>
<tr><td><code>GraphErrors::IdenticalIndices</code></td><td><code>index2 == index1</code> not allowed!</td></tr>
<tr><td><code>GraphErrors::EdgeExists</code></td><td>requested edge already exists!</td></tr>
</tbody></table>
</div><h4 id='method.remove_edge' class="method"><code id='remove_edge.v'>pub fn <a href='#method.remove_edge' class='fnname'>remove_edge</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;index1: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;index2: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="enum" href="../../net_ensembles/graph/enum.GraphErrors.html" title="enum net_ensembles::graph::GraphErrors">GraphErrors</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#668-673' title='goto source code'>[src]</a></h4><div class='docblock'><p>Removes edge between nodes <em>index1</em> and <em>index2</em></p>
<h2 id="errorcases-1" class="section-header"><a href="#errorcases-1">ErrorCases:</a></h2><table><thead><tr><th>Error</th><th>Reason</th></tr></thead><tbody>
<tr><td><code>GraphErrors::IndexOutOfRange</code></td><td><code>index1</code> or <code>index2</code> larger than <code>self.vertex_count()</code></td></tr>
<tr><td><code>GraphErrors::IdenticalIndices</code></td><td><code>index2 == index1</code> not allowed!</td></tr>
<tr><td><code>GraphErrors::EdgeDoesNotExist</code></td><td>requested edge does not exists</td></tr>
</tbody></table>
</div><h4 id='method.edge_count' class="method"><code id='edge_count.v'>pub fn <a href='#method.edge_count' class='fnname'>edge_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#676-678' title='goto source code'>[src]</a></h4><div class='docblock'><p>returns total number of edges in graph</p>
</div><h4 id='method.edge_count_at' class="method"><code id='edge_count_at.v'>pub fn <a href='#method.edge_count_at' class='fnname'>edge_count_at</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#681-688' title='goto source code'>[src]</a></h4><h4 id='method.dfs' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../net_ensembles/graph/struct.Dfs.html" title="struct net_ensembles::graph::Dfs">Dfs</a>&lt;'a, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../net_ensembles/graph/struct.Dfs.html" title="struct net_ensembles::graph::Dfs">Dfs</a>&lt;'a, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../net_ensembles/graph/struct.Dfs.html" title="struct net_ensembles::graph::Dfs">Dfs</a>&lt;'a, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T;</span></code></div></div><code id='dfs.v'>pub fn <a href='#method.dfs' class='fnname'>dfs</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="../../net_ensembles/graph/struct.Dfs.html" title="struct net_ensembles::graph::Dfs">Dfs</a>&lt;T&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#705-707' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="returns-iterator" class="section-header"><a href="#returns-iterator">returns <code>Iterator</code></a></h1>
<ul>
<li>the iterator will iterate over the vertices in depth first search order,
beginning with vertex <code>index</code>.</li>
<li>iterator returns <code>node</code></li>
</ul>
<h2 id="order" class="section-header"><a href="#order">Order</a></h2>
<p>Order is guaranteed to be in DFS order, however
if this order is not unambigouse
adding edges and especially removing edges will shuffle the order.</p>
<h2 id="note" class="section-header"><a href="#note">Note:</a></h2>
<p>Will only iterate over vertices within the connected component that contains vertex <code>index</code></p>
</div><h4 id='method.dfs_with_index' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../net_ensembles/graph/struct.DfsWithIndex.html" title="struct net_ensembles::graph::DfsWithIndex">DfsWithIndex</a>&lt;'a, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../net_ensembles/graph/struct.DfsWithIndex.html" title="struct net_ensembles::graph::DfsWithIndex">DfsWithIndex</a>&lt;'a, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../net_ensembles/graph/struct.DfsWithIndex.html" title="struct net_ensembles::graph::DfsWithIndex">DfsWithIndex</a>&lt;'a, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='dfs_with_index.v'>pub fn <a href='#method.dfs_with_index' class='fnname'>dfs_with_index</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="../../net_ensembles/graph/struct.DfsWithIndex.html" title="struct net_ensembles::graph::DfsWithIndex">DfsWithIndex</a>&lt;T&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#724-726' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="returns-iterator-1" class="section-header"><a href="#returns-iterator-1">returns <code>Iterator</code></a></h1>
<ul>
<li>the iterator will iterate over the vertices in depth first search order,
beginning with vertex <code>index</code>.</li>
<li>Iterator returns tuple <code>(index, node)</code></li>
</ul>
<h2 id="order-1" class="section-header"><a href="#order-1">Order</a></h2>
<p>Order is guaranteed to be in DFS order, however
if this order is not unambigouse
adding edges and especially removing edges will shuffle the order.</p>
<h2 id="note-1" class="section-header"><a href="#note-1">Note:</a></h2>
<p>Will only iterate over vertices within the connected component that contains vertex <code>index</code></p>
</div><h4 id='method.bfs_index_depth' class="method"><div class="important-traits"><div class='tooltip'>ⓘ<span class='tooltiptext'>Important traits for <a class="struct" href="../../net_ensembles/graph/struct.Bfs.html" title="struct net_ensembles::graph::Bfs">Bfs</a>&lt;'a, T&gt;</span></div><div class="content hidden"><h3 class="important">Important traits for <a class="struct" href="../../net_ensembles/graph/struct.Bfs.html" title="struct net_ensembles::graph::Bfs">Bfs</a>&lt;'a, T&gt;</h3><code class="content"><span class="where fmt-newline">impl&lt;'a, T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../../net_ensembles/graph/struct.Bfs.html" title="struct net_ensembles::graph::Bfs">Bfs</a>&lt;'a, T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href='https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item' class="type">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a </a>T, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>;</span></code></div></div><code id='bfs_index_depth.v'>pub fn <a href='#method.bfs_index_depth' class='fnname'>bfs_index_depth</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="struct" href="../../net_ensembles/graph/struct.Bfs.html" title="struct net_ensembles::graph::Bfs">Bfs</a>&lt;T&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#748-750' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="returns-iterator-2" class="section-header"><a href="#returns-iterator-2">returns <code>Iterator</code></a></h1>
<ul>
<li>the iterator will iterate over the vertices in breadth first search order,
beginning with vertex <code>index</code>.</li>
<li>Iterator returns tuple <code>(index, node, depth)</code></li>
</ul>
<h3 id="depth" class="section-header"><a href="#depth">depth</a></h3>
<ul>
<li>starts at 0 (i.e. the first element in the iterator will have <code>depth = 0</code>)</li>
<li><code>depth</code> equals number of edges in the <em>shortest path</em> from the <em>current</em> vertex to the
<em>first</em> vertex (i.e. to the vertex with index <code>index</code>)</li>
</ul>
<h2 id="order-2" class="section-header"><a href="#order-2">Order</a></h2>
<p>Order is guaranteed to be in BFS order, however
if this order is not unambigouse
adding edges and especially removing edges will shuffle the order.</p>
<h2 id="note-2" class="section-header"><a href="#note-2">Note:</a></h2>
<p>Will only iterate over vertices within the connected component that contains vertex <code>index</code></p>
</div><h4 id='method.is_connected' class="method"><code id='is_connected.v'>pub fn <a href='#method.is_connected' class='fnname'>is_connected</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#757-763' title='goto source code'>[src]</a></h4><div class='docblock'><table><thead><tr><th>result</th><th>condition</th></tr></thead><tbody>
<tr><td><code>None</code></td><td><strong>if</strong> graph does not contain any vertices</td></tr>
<tr><td><code>Some(true)</code></td><td><strong>else if</strong> all vertices are connected by paths of edges</td></tr>
<tr><td><code>Some(false)</code></td><td><strong>otherwise</strong></td></tr>
</tbody></table>
</div><h4 id='method.q_core' class="method"><code id='q_core.v'>pub fn <a href='#method.q_core' class='fnname'>q_core</a>(&amp;self, q: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#801-874' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="definition" class="section-header"><a href="#definition">definition</a></h1>
<p>Calculates the size of the <strong>q-core</strong> (i.e. number of nodes in the biggest possible set of nodes,
where all nodes from the set are connected with at least <code>q</code> other nodes from the set)</p>
<p>returns <code>None</code> if impossible to calculate (e.g. <code>vertex_count == 0</code> or <code>q &lt;= 1</code>)</p>
<h1 id="example-1" class="section-header"><a href="#example-1">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">net_ensembles</span>::<span class="ident">TestNode</span>;
<span class="kw">use</span> <span class="ident">net_ensembles</span>::<span class="ident">Graph</span>;

<span class="kw">let</span> <span class="ident">graph</span>: <span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">TestNode</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Graph</span>::<span class="ident">new</span>(<span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">graph</span>.<span class="ident">q_core</span>(<span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">graph</span>.<span class="ident">q_core</span>(<span class="number">2</span>), <span class="prelude-val">None</span>);

<span class="kw">let</span> <span class="ident">graph2</span>: <span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">TestNode</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Graph</span>::<span class="ident">new</span>(<span class="number">1</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">graph2</span>.<span class="ident">q_core</span>(<span class="number">1</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">graph2</span>.<span class="ident">q_core</span>(<span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));


<span class="comment">// create complete graph</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">graph3</span>: <span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">TestNode</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Graph</span>::<span class="ident">new</span>(<span class="number">20</span>);
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="ident">graph3</span>.<span class="ident">vertex_count</span>() {
    <span class="kw">for</span> <span class="ident">j</span> <span class="kw">in</span> <span class="ident">i</span><span class="op">+</span><span class="number">1</span>..<span class="ident">graph3</span>.<span class="ident">vertex_count</span>() {
        <span class="ident">graph3</span>.<span class="ident">add_edge</span>(<span class="ident">i</span>, <span class="ident">j</span>).<span class="ident">unwrap</span>();
    }
}

<span class="comment">// since this is a complete graph, the q-core should always consist of 20 nodes</span>
<span class="comment">// as long as q &lt; 20, as every node has 19 neighbors</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">2</span>..<span class="number">20</span> {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">graph3</span>.<span class="ident">q_core</span>(<span class="ident">i</span>), <span class="prelude-val">Some</span>(<span class="number">20</span>));
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">graph3</span>.<span class="ident">q_core</span>(<span class="number">20</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));</pre></div>
</div><h4 id='method.connected_components' class="method"><code id='connected_components.v'>pub fn <a href='#method.connected_components' class='fnname'>connected_components</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#882-921' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="compute-sizes-of-all-connected-components" class="section-header"><a href="#compute-sizes-of-all-connected-components">compute sizes of all <em>connected components</em></a></h1>
<ul>
<li>the <strong>number</strong> of connected components is the <strong>size</strong> of the returned vector, i.e. <code>result.len()</code></li>
<li>returns <strong>empty</strong> vector, if graph does not contain vertices</li>
<li>returns (reverse) <strong>ordered vector of sizes</strong> of the connected components,
i.e. the biggest component is of size <code>result[0]</code> and the smallest is of size <code>result[result.len() - 1]</code></li>
</ul>
</div><h4 id='method.leaf_count' class="method"><code id='leaf_count.v'>pub fn <a href='#method.leaf_count' class='fnname'>leaf_count</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#924-929' title='goto source code'>[src]</a></h4><div class='docblock'><p>Count number of leaves in the graph, i.e. vertices with exactly one neighbor</p>
</div><h4 id='method.to_dot' class="method"><code id='to_dot.v'>pub fn <a href='#method.to_dot' class='fnname'>to_dot</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#935-952' title='goto source code'>[src]</a></h4><div class='docblock'><ul>
<li>Creates String which contains the topology of the network in a format
that can be used by <strong>circo</strong> etc. to generate a pdf of the graph.</li>
<li><strong>indices</strong> are used as <strong>labels</strong></li>
<li>search for <strong>graphviz</strong> to learn about <strong>.dot</strong> format</li>
</ul>
</div><h4 id='method.to_dot_with_labels' class="method"><code id='to_dot_with_labels.v'>pub fn <a href='#method.to_dot_with_labels' class='fnname'>to_dot_with_labels</a>&lt;F&gt;(&amp;self, dot_options: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, f: F) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn">Fn</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>,&nbsp;</span></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#999-1024' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="example-2" class="section-header"><a href="#example-2">Example</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">net_ensembles</span>::{<span class="ident">Graph</span>,<span class="ident">TestNode</span>,<span class="ident">DEFAULT_DOT_OPTIONS</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">graph</span>: <span class="ident">Graph</span><span class="op">&lt;</span><span class="ident">TestNode</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Graph</span>::<span class="ident">new</span>(<span class="number">3</span>);
<span class="ident">graph</span>.<span class="ident">add_edge</span>(<span class="number">0</span>, <span class="number">1</span>).<span class="ident">unwrap</span>();
<span class="ident">graph</span>.<span class="ident">add_edge</span>(<span class="number">0</span>, <span class="number">2</span>).<span class="ident">unwrap</span>();
<span class="ident">graph</span>.<span class="ident">add_edge</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="ident">unwrap</span>();

<span class="comment">// create string of dotfile</span>
<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">graph</span>.<span class="ident">to_dot_with_labels</span>(
   <span class="ident">DEFAULT_DOT_OPTIONS</span>,
   <span class="op">|</span><span class="ident">_contained</span>, <span class="ident">index</span><span class="op">|</span> <span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;Hey {}!&quot;</span>, <span class="ident">index</span>)
);

<span class="comment">// write to file</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">f</span> <span class="op">=</span> <span class="ident">File</span>::<span class="ident">create</span>(<span class="string">&quot;example.dot&quot;</span>).<span class="ident">expect</span>(<span class="string">&quot;Unable to create file&quot;</span>);
<span class="ident">f</span>.<span class="ident">write_all</span>(<span class="ident">s</span>.<span class="ident">as_bytes</span>()).<span class="ident">expect</span>(<span class="string">&quot;Unable to write data&quot;</span>);
</pre></div>
<p>In this example, <code>example.dot</code> now contains:</p>
<pre><code class="language-dot">graph G{
    bgcolor=&quot;transparent&quot;;
    fontsize=50;
    node [shape=ellipse, penwidth=1, fontname=&quot;Courier&quot;, pin=true ];
    splines=true;
    0 1 2 ;
    &quot;0&quot; [label=&quot;Hey 0!&quot;];
    &quot;1&quot; [label=&quot;Hey 1!&quot;];
    &quot;2&quot; [label=&quot;Hey 2!&quot;];
    0 -- 1
    0 -- 2
    1 -- 2
}
</code></pre>
<p>Then you can use, e.g.,</p>
<pre><code class="language-console">foo@bar:~$ circo example.dot -Tpdf &gt; example.pdf
</code></pre>
<p>to create a <strong>pdf</strong> representation from it.
Search for <strong>graphviz</strong> to learn more.</p>
</div><h4 id='method.diameter' class="method"><code id='diameter.v'>pub fn <a href='#method.diameter' class='fnname'>diameter</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#1028-1041' title='goto source code'>[src]</a></h4><div class='docblock'><ul>
<li>returns <code>None</code> <strong>if</strong> graph not connected <strong>or</strong> does not contain any vertices</li>
<li>uses repeated breadth first search</li>
</ul>
</div><h4 id='method.longest_shortest_path_from_index' class="method"><code id='longest_shortest_path_from_index.v'>pub fn <a href='#method.longest_shortest_path_from_index' class='fnname'>longest_shortest_path_from_index</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#1045-1049' title='goto source code'>[src]</a></h4><div class='docblock'><p>calculate the size of the longest shortest path <strong>starting from</strong> vertex with <strong>index</strong> <code>index</code>
using breadth first search</p>
</div><h4 id='method.vertex_biconnected_components' class="method"><code id='vertex_biconnected_components.v'>pub fn <a href='#method.vertex_biconnected_components' class='fnname'>vertex_biconnected_components</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;alternative_definition: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><br>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#1078-1198' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="calculate-sizes-of-all-binode-connected-components" class="section-header"><a href="#calculate-sizes-of-all-binode-connected-components">calculate sizes of all binode connected components</a></h1>
<ul>
<li>returns (reverse) <strong>ordered vector of sizes</strong>
i.e. the biggest component is of size <code>result[0]</code> and the smallest is of size <code>result[result.len() - 1]</code></li>
<li>destroys the underlying topology and therefore moves <code>self</code></li>
<li>if you still need your graph,
use <code>self.clone().vertex_biconnected_components(false/true)</code> for your calculations</li>
</ul>
<h1 id="definition-vertex_biconnected_componentsfalse" class="section-header"><a href="#definition-vertex_biconnected_componentsfalse">Definition: <code>vertex_biconnected_components(false)</code></a></h1>
<p>Here, the (vertex) biconnected component of a graph is defined as maximal subset of nodes,
where any one node could be removed and the remaining nodes would still be a connected component.</p>
<h2 id="note-3" class="section-header"><a href="#note-3">Note</a></h2>
<p>Two vertices connected by an edge are considered to be biconnected, since after the
removal of one vertex (and the corresponding edge), only one vertex remains.
This vertex is in a connected component with itself.</p>
<h1 id="alternative-definition-vertex_biconnected_componentstrue" class="section-header"><a href="#alternative-definition-vertex_biconnected_componentstrue">Alternative Definition: <code>vertex_biconnected_components(true)</code></a></h1>
<p>If you want to use the alternative definition:</p>
<blockquote>
<p>The biconnected component is defined as maximal subset of vertices, where each vertex can be
reached by at least two node independent paths</p>
</blockquote>
<p>The alternative definition just removes all 2s from the result vector.</p>
<h1 id="citations" class="section-header"><a href="#citations">Citations</a></h1>
<p>I used the algorithm described in this paper:</p>
<blockquote>
<p>J. Hobcroft and R. Tarjan, &quot;Algorithm 447: Efficient Algorithms for Graph Manipulation&quot;
<em>Commun. ACM</em>, <strong>16</strong>:372-378, 1973, DOI: <a href="https://doi.org/10.1145/362248.362272">10.1145/362248.362272</a></p>
</blockquote>
<p>You can also take a look at:</p>
<blockquote>
<p>M. E. J. Newman, &quot;Networks: an Introduction&quot; <em>Oxfort University Press</em>, 2010, ISBN: 978-0-19-920665-0.</p>
</blockquote>
</div><h4 id='method.vertex_load' class="method"><code id='vertex_load.v'>pub fn <a href='#method.vertex_load' class='fnname'>vertex_load</a>(&amp;self, include_endpoints: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a>&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#1217-1277' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="closely-related-most-of-the-time-equal-to-betweeness" class="section-header"><a href="#closely-related-most-of-the-time-equal-to-betweeness">Closely related (most of the time equal) to betweeness</a></h1><h2 id="calculates-vertex_load-of-all-vertices-in-oedges--vertices" class="section-header"><a href="#calculates-vertex_load-of-all-vertices-in-oedges--vertices">calculates vertex_load of all vertices in O(edges * vertices)</a></h2>
<ul>
<li>calculates the vertex_load for every vertex</li>
<li>defined as how many shortest paths pass through each vertex</li>
</ul>
<table><thead><tr><th>variant</th><th></th></tr></thead><tbody>
<tr><td><code>vertex_load(true)</code></td><td>includes endpoints in calculation (for a complete graph with <code>N</code> vertices, every node will have vertex_load <code>N - 1</code>)</td></tr>
<tr><td><code>vertex_load(false)</code></td><td>excludes endpoints in calculation (for a complete graph with <code>N</code> vertices, every node will have vertex_load <code>0</code>)</td></tr>
</tbody></table>
<h1 id="citations-1" class="section-header"><a href="#citations-1">Citations</a></h1>
<p>I used the algorithm described in</p>
<blockquote>
<p>M. E. J. Newman, &quot;Scientific collaboration networks. II. Shortest paths, weighted networks, and centrality&quot;,
Phys. Rev. E <strong>64</strong>, 016132, 2001, DOI: <a href="https://doi.org/10.1103/PhysRevE.64.016132">10.1103/PhysRevE.64.016132</a></p>
</blockquote>
<p>see also:</p>
<blockquote>
<p>M. E. J. Newman, &quot;Erratum: Scientific collaboration networks. II. Shortest paths, weighted networks, and centrality&quot;,
Phys. Rev. E <strong>73</strong>, 039906, 2006, DOI: <a href="https://doi.org/10.1103/PhysRevE.73.039906">10.1103/PhysRevE.73.039906</a></p>
</blockquote>
</div><h4 id='method.transitivity' class="method"><code id='transitivity.v'>pub fn <a href='#method.transitivity' class='fnname'>transitivity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.f64.html">f64</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#1288-1313' title='goto source code'>[src]</a></h4><div class='docblock'><h1 id="calculates-transitivity-of-graph" class="section-header"><a href="#calculates-transitivity-of-graph">Calculates transitivity of graph</a></h1>
<ul>
<li>related to cluster coefficient (Note: transitivity and cluster coefficient are similar,
but <strong>not</strong> necessarily equal)</li>
<li>returns <code>NaN</code>, if there are no paths of length two in the graph</li>
</ul>
<h2 id="definition-1" class="section-header"><a href="#definition-1">Definition</a></h2>
<blockquote>
<p>transitivity = (number of closed paths of length two) / (number of paths of length two)</p>
</blockquote>
<h2 id="citations-2" class="section-header"><a href="#citations-2">Citations</a></h2>
<p>For the definition see for example:</p>
<blockquote>
<p>M. E. J. Newman, &quot;Networks: an Introduction&quot; <em>Oxfort University Press</em>, 2010, ISBN: 978-0-19-920665-0.</p>
</blockquote>
</div></div><h2 id='implementations' class='small-section-header'>Trait Implementations<a href='#implementations' class='anchor'></a></h2><div id='implementations-list'><h3 id='impl-Clone' class='impl'><code class='in-band'>impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> + <a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt;</code><a href='#impl-Clone' class='anchor'></a><a class='srclink' href='../../src/net_ensembles/graph.rs.html#480' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.clone' class="method hidden"><code id='clone.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt;</code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#480' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id='method.clone_from' class="method hidden"><code id='clone_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class='since' title='Stable since Rust version 1.0.0'>1.0.0</span><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/clone.rs.html#131-133' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><h3 id='impl-Debug' class='impl'><code class='in-band'>impl&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> + <a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt;</code><a href='#impl-Debug' class='anchor'></a><a class='srclink' href='../../src/net_ensembles/graph.rs.html#480' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt' class="method hidden"><code id='fmt.v'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#480' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></div><h3 id='impl-Display' class='impl'><code class='in-band'>impl&lt;T:&nbsp;<a class="trait" href="../../net_ensembles/node/trait.Node.html" title="trait net_ensembles::node::Node">Node</a>&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt;</code><a href='#impl-Display' class='anchor'></a><a class='srclink' href='../../src/net_ensembles/graph.rs.html#487-495' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.fmt-1' class="method hidden"><code id='fmt.v-1'>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></code><a class='srclink' href='../../src/net_ensembles/graph.rs.html#488-494' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></div></div><h2 id='synthetic-implementations' class='small-section-header'>Auto Trait Implementations<a href='#synthetic-implementations' class='anchor'></a></h2><div id='synthetic-implementations-list'><h3 id='impl-RefUnwindSafe' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></code><a href='#impl-RefUnwindSafe' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Send' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,&nbsp;</span></code><a href='#impl-Send' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Sync' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a>,&nbsp;</span></code><a href='#impl-Sync' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-Unpin' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code><a href='#impl-Unpin' class='anchor'></a></h3><div class='impl-items'></div><h3 id='impl-UnwindSafe' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="../../net_ensembles/graph/struct.Graph.html" title="struct net_ensembles::graph::Graph">Graph</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a>,&nbsp;</span></code><a href='#impl-UnwindSafe' class='anchor'></a></h3><div class='impl-items'></div></div><h2 id='blanket-implementations' class='small-section-header'>Blanket Implementations<a href='#blanket-implementations' class='anchor'></a></h2><div id='blanket-implementations-list'><h3 id='impl-Any' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Any' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#108-112' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.type_id' class="method hidden"><code id='type_id.v'>fn <a href='https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id' class='fnname'>type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/any.rs.html#109-111' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div><h3 id='impl-Borrow%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-Borrow%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#213-217' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow' class="method hidden"><code id='borrow.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow' class='fnname'>borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214-216' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><h3 id='impl-BorrowMut%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-BorrowMut%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#220-224' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.borrow_mut' class="method hidden"><code id='borrow_mut.v'>fn <a href='https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut' class='fnname'>borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221-223' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><h3 id='impl-From%3CT%3E' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href='#impl-From%3CT%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#564-568' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.from' class="method hidden"><code id='from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from' class='fnname'>from</a>(t: T) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#565-567' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-Into%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-Into%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#553-560' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.into' class="method hidden"><code id='into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into' class='fnname'>into</a>(self) -&gt; U</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#557-559' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-ToOwned' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href='#impl-ToOwned' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#80-92' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Owned' class="type"><code id='Owned.t'>type <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned' class="type">Owned</a> = T</code></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id='method.to_owned' class="method hidden"><code id='to_owned.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned' class='fnname'>to_owned</a>(&amp;self) -&gt; T</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#85-87' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id='method.clone_into' class="method hidden"><code id='clone_into.v'>fn <a href='https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into' class='fnname'>clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#89-91' title='goto source code'>[src]</a></h4><div class='stability hidden'><div class='stab unstable'><details><summary><span class='emoji'>🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div><h3 id='impl-ToString' class='impl'><code class='in-band'>impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href='#impl-ToString' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2167-2177' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='method.to_string' class="method hidden"><code id='to_string.v'>default fn <a href='https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string' class='fnname'>to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2169-2176' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/nightly/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></div><h3 id='impl-TryFrom%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryFrom%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#601-610' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error' class="type"><code id='Error.t'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error' class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_from' class="method hidden"><code id='try_from.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from' class='fnname'>try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#607-609' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-TryInto%3CU%3E' class='impl'><code class='in-band'>impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href='#impl-TryInto%3CU%3E' class='anchor'></a><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587-596' title='goto source code'>[src]</a></h3><div class='impl-items'><h4 id='associatedtype.Error-1' class="type"><code id='Error.t-1'>type <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error' class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id='method.try_into' class="method hidden"><code id='try_into.v'>fn <a href='https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into' class='fnname'>try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a class='srclink' href='https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#593-595' title='goto source code'>[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div><h3 id='impl-VZip%3CV%3E' class='impl'><code class='in-band'>impl&lt;V, T&gt; VZip&lt;V&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: MultiLane&lt;T&gt;,&nbsp;</span></code><a href='#impl-VZip%3CV%3E' class='anchor'></a></h3><div class='impl-items'><h4 id='method.vzip' class="method hidden"><code id='vzip.v'>fn <a href='#method.vzip' class='fnname'>vzip</a>(self) -&gt; V</code></h4></div></div></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "net_ensembles";</script><script src="../../aliases.js"></script><script src="../../main.js"></script><script defer src="../../search-index.js"></script></body></html>